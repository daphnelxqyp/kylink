# 需求0108：Google Ads Scripts 自动写入 Final URL Suffix（超简单上线版）

> **日期**：2026-01-08（修正版 2026-01-20）  
> **目标一句话**：按可配置频率读取"今日累计 clicks"，把 clicks 上报给 API；**API 判定 `delta>0` 才发 1 条 suffix**；脚本写入 `Campaign.final_url_suffix` 后 **必须 ack**（可重试、幂等、不重复耗库存）。

---

## 📋 项目审计摘要（2026-01-20 更新）

### 当前进度总览

| 模块 | 完成度 | 状态 |
|------|--------|------|
| 核心 API (lease/ack/sync) | 100% | ✅ 已完成 |
| 批量接口 (batch) | 100% | ✅ 已完成 |
| 库存补货系统 | 95% | ⚠️ 需整合代理 |
| 租约超时回收 | 100% | ✅ 已完成 |
| 监控告警系统 | 90% | ⚠️ 告警需持久化 |
| 前端管理界面 | 100% | ✅ 已完成 |
| 联盟网络同步 | 100% | ✅ 7个平台 |
| 代理验证系统 | 100% | ✅ 已完成 |
| 代理 → Suffix 生成 | 60% | 🔧 待整合 |

### 待修复问题清单

#### 🚨 严重 (P0)

1. **Prisma findUnique 查询语法错误**
   - 文件: `src/app/api/v1/suffix/lease/route.ts`
   - 问题: `findUnique` 的 where 条件中包含非 unique 字段 `deletedAt: null`
   - 影响: 可能返回已软删除的记录，破坏数据一致性
   - 修复方案: 改用 `findFirst` 或分两步查询

2. **批量 lease 同样问题**
   - 文件: `src/app/api/v1/suffix/lease/batch/route.ts`
   - 需同步修复

#### ⚠️ 重要 (P1)

3. **代理逻辑未整合到 Suffix 生成**
   - 当前: `suffix-generator.ts` 有独立的简化代理逻辑
   - 已有: `redirect/tracker.ts` 有完整的代理追踪能力
   - 建议: 复用 tracker 模块到 suffix 生成流程

4. **告警历史内存存储**
   - 当前: 告警存储在内存数组中
   - 问题: 服务重启会丢失告警历史
   - 建议: 持久化到数据库或 Redis

#### 💡 优化 (P2)

5. **租约恢复模块文件缺失**
   - 需确认 `lease-recovery.ts` 是否正确导出

6. **联盟商家数据优化**
   - 当前已保存了大量商家数据 (JSON 文件)
   - 建议: 确保数据库同步逻辑正确

---

## 1. 这套系统由谁来做什么？

- **Google Ads Scripts（按 `cycleMinutes` 周期巡检，可配置）**
  - 读：每个 Campaign 的"今日累计 clicks（TODAY）"
  - 报：把 `nowClicks` 上报给 API（**不在表格里做 lastClicks/锁**）
  - 写：当 API 返回 `action=APPLY` 时，只做一件事——**把 suffix 写回去**，并立刻 ack

- **Suffix API（我们的轻量后端）**
  - 先准备一批"可以直接写进去的 suffix"（像库存一样存着）
  - 当 Scripts 来请求（携带 `nowClicks`）时：
    - **若 `delta=nowClicks-lastAppliedClicks>0`**：发放 1 条 suffix（幂等、同一窗口不重复耗库存）
    - 否则返回 `NOOP`（不换链）
  - 库存快没了，就继续"生产"新的 suffix 补货
  - "生产 suffix"时会做：
    - **联盟跳转追踪**（从联盟链接一路跳转到最终 URL）
    - **代理去重**（同一个广告系列 24 小时内尽量不重复用同一出口 IP）

---

## 2. Scripts 每轮（cycle）具体怎么做？

1. 找到 MCC 下面所有 CID(active) 的 Campaign(enabled)
2. 对每个 Campaign 读取：**今日累计 clicks（TODAY）**
3. 单调递增保护（防止数据回落）：`nowClicksForDecision = max(nowClicks, lastObservedClicks)`
4. 生成本轮窗口参数：
   - `cycleMinutes`：用户配置（上线默认建议 >= 10）
   - `windowStartEpochSeconds`：按 `cycleMinutes` 分桶对齐
   - `idempotencyKey = campaignId + ":" + windowStartEpochSeconds + ":" + nowClicksForDecision`
5. 调用 Suffix API：
   - `POST /v1/suffix/lease`
   - Body：`{ campaignId, nowClicks, observedAt, scriptInstanceId, cycleMinutes, windowStartEpochSeconds, idempotencyKey }`
6. 判断 API 返回：
   - **`action=NOOP`**：本轮不换链
   - **`code=NO_STOCK`**：记录日志并跳过（下轮再试）
   - **`code=PENDING_IMPORT`**：记录日志并跳过（下轮再试）
   - **`action=APPLY`**：说明有新增点击（`delta>0`），但**不管新增多少（N>1）都只换 1 次**
     - 写入 `Campaign.final_url_suffix = finalUrlSuffix`（Campaign 级别）
     - **立即调用 `POST /v1/suffix/ack` 回执**（失败重试 3 次）
   - **`code=LEASE_EXPIRED`**：租约已过期，重新 lease

> 说明：我们用"今日累计 clicks"做触发判定，不追求"刚好 1 分钟内的真实点击数"，因为 Google Ads 数据可能有延迟。

---

## 3. Suffix API 要提供哪些接口？（简单够用版）

> 每个用户只有 1 个 API 链接（也就是 1 个 baseUrl + 1 个密钥）。

- **1）请求换链决策 + 领取 1 条 suffix（幂等）**
  - **POST** `/v1/suffix/lease`
  - **请求**：
    - `campaignId: string`
    - `nowClicks: number`
    - `observedAt: string`
    - `scriptInstanceId: string`
    - `cycleMinutes: number`
    - `windowStartEpochSeconds: number`
    - `idempotencyKey: string`
  - **返回（200）**：
    - `action: "APPLY" | "NOOP"`
    - `leaseId?: string`
    - `finalUrlSuffix?: string`
  - **缺货（409/503）**：`code=NO_STOCK`
  - **导入中（202）**：`code=PENDING_IMPORT`（触发异步导入）

- **2）回执（强烈建议，Scripts 写入后必须立刻回执）**
  - **POST** `/v1/suffix/ack`
  - **请求**：`{ leaseId: string, campaignId: string, applied: boolean, appliedAt: string, errorMessage?: string }`
  - **用途**：记录"写入成功/失败"，方便排查问题
  - **重要性**：无回执将导致 suffix 状态无法正确更新，影响库存回收

---

## 4. "suffix 库存池"是什么？怎么补货？

- **库存里存的是什么**：已经追踪好的、可以直接写入的 `finalUrlSuffix`
- **库存是谁的**：一用户一库存（不会串号）
- **库存怎么分**：按 Campaign 分开（每个 Campaign 单独库存）
- **默认一次生产**：10 条（可配置）
- **低水位补货**：当库存少于 3 条（可配置）时，后台继续生产 10 条
- **同一条 suffix 只能用一次**：发给 Scripts 后就算消耗
- **suffix 有效期**：生产后超过 48 小时（可配置）未被使用的 suffix 应标记为过期并清理
- **leased 超时回收**：suffix 处于 `leased` 状态超过 10-15 分钟（可配置）且无 ack 回执，自动回收为 `available` 状态

> 补货策略补充：
> - **实时触发**：每次 `lease` 请求成功后，异步检查该 campaign 库存，若低于阈值则加入补货队列
> - **定时兜底**：每 5 分钟全量扫描所有用户的所有 campaign，补漏
> - **优先级**：优先处理"库存最少"的 campaign
> - **异步约束**：补货任务必须异步执行，不得阻塞 `lease` 等在线请求

---

## 5. 多账号、多用户怎么隔离？

- 一个系统服务多个用户
- 每个用户可以有多个 MCC
- **API 鉴权**：Scripts 调用 API 时带上用户的密钥（例如 `Authorization: Bearer <API_KEY>`）
- **一个 API Key 服务所有 MCC**：同一用户的多个 MCC 共用一个 API Key，API 通过请求中的 `campaignId`（全局唯一）自动关联到正确的 MCC
- API 只给这个用户自己的 Campaign 发 suffix（不会串到别的用户）
- **Google 表格绑定**：每个用户登录系统后，需要设置自己的 `spreadsheetId`

---

## 6. 必须遵守的关键规则（最重要）

- **规则 A**：新增点击 `delta > 0` 才换链
- **规则 B**：新增点击 **N>1 也只换 1 次**
- **规则 C**：Scripts 只负责"写 suffix"，不做跳转追踪、不做代理选择
- **规则 D**：API 返回的必须是"可直接写入的 `finalUrlSuffix`"
- **规则 E**：suffix 采用"库存池"方式：先生产、再发放、快没了再补货
- **规则 F**：只处理 **CID 状态为 `active`** 且 **Campaign 状态为 `enabled`** 的数据
- **规则 G**：API 缺货时返回 `NO_STOCK`，Scripts 记录日志并跳过（下次循环再试）
- **规则 H**：`lastAppliedClicks` 由 **API 侧保存**（一致性状态源），表格不做锁/不做 lastClicks
- **规则 I**：同一 campaign 同一窗口（`idempotencyKey`）必须幂等，不重复耗库存
- **规则 J**：suffix 的 `leased` 状态超过 10-15 分钟无回执，自动回收为 `available` 状态；Scripts 侧 ack 失败时重试 3 次

---

## 7. 使用场景（你描述的完整流程）

### 7.1 Scripts（先把清单写到 Google 表格，再循环换链）

> 重要前提：Google Ads Scripts 单次执行最长约 **30 分钟**。为实现"长期持续巡检"，可采用 **单脚本**或 **复制 2 份同脚本 A/B 错峰 ~30 分钟**；一致性由 API 保证，无需表格锁。

#### 7.1.1 Scripts 侧首次配置（每个脚本都要填）

- 设置当前 MCC 可读写的 **Google 表格 URL/SpreadsheetId**（脚本会向该表写入清单）
- 设置 **Suffix API BaseUrl** 与 **ApiKey**
- 设置 `cycleMinutes`（建议默认 10；上线默认不低于 10）

#### 7.1.2 单次运行：先刷新清单，再进入 30 分钟内的循环检测

1. **刷新清单（写入 Sheet1）**
   - 扫描当前 MCC 下所有 **有效 CID（active）**
   - 再扫描每个 CID 下所有 **有效 Campaign（enabled）**
   - 把这些信息写入 Google 表格的 **Sheet1（清单）**：
     - `campaignName`：广告系列名称
     - `campaignId`：广告系列 ID
     - `country`：投放国家（例如 US、UK），用于代理选择时匹配出口国家
     - `finalUrl`：最终到达网址
     - `todayClicks`：今日累计点击数（使用 `segments.date DURING TODAY` 和 `metrics.clicks` 获取，无今日数据时默认为 0）
     - `cid`：子账号 CID（必需）
     - `mccId`：MCC ID（必需）
     - `updatedAt`：写入时间
2. **30 分钟内循环检测（间隔=cycleMinutes）**
   - 读取每个 Campaign 的"今日累计 clicks（TODAY）"
   - 调用 `lease` 上报 `nowClicks`，由 API 基于 `lastAppliedClicks` 判定是否换链
   - 若 `action=APPLY`：写入 suffix 并 **立即 ack**（ack 失败重试 3 次）
   - 若 `NO_STOCK/PENDING_IMPORT`：记录日志跳过
   - 若 `UNAUTHORIZED`：记录错误日志并终止（需人工修复配置）

#### 7.1.3 长期调度：2 个脚本错峰覆盖（可选）

为规避 30 分钟上限，并尽量做到"持续巡检"：

- 复制同一份脚本为 **Script-A**、**Script-B**
- **共享状态**：两份脚本无需共享表格状态；由 **API 保证幂等与单活跃租约**，避免重复换链
- **错峰启动**：先启动 Script-A，间隔约 **30 分钟**再启动 Script-B
- **触发频率**：两份脚本都设置为 **每 1 小时运行一次**
  - 这样 A/B 会交替运行，整体上可以做到 **每 30 分钟进入一次"30 分钟内的分钟级循环"**（相当于长期连续覆盖）

### 7.2 API（从表格导入一次防漏，然后预生产库存）

1. 用户登录系统后先完成基础配置：
   - 绑定该用户的 `spreadsheetId`（对应 MCC 可读写的 Google 表格）
2. 用户点击"刷新表格/提取清单"（或由 Scripts 运行自动刷新）后：
   - API 侧由管理员/用户**手动导入一次** Google 表格的 Sheet1（清单）
   - 目的：避免漏掉 Campaign（以表格清单为准）
3. 用户对"缺少联盟链接"的 Campaign 批量补全：
   - 给每个 Campaign 配置 1~N 条联盟入口链接（Affiliate Link）
4. 用户点击"一键生成 suffix 池（先补满）"：
   - 按预设量（例如 `produceBatchSize=10`）为每个 Campaign 先生产并补满库存
   - 生产过程包含：代理访问联盟链接、联盟跳转追踪、代理出口 IP 去重
5. 用户点击"一键启动服务"：
   - 对外开放 Scripts 端调用的 `lease/ack` 等接口
6. 服务运行期间：
   - API 持续监控库存：当库存低于低水位（例如 `< lowWatermark=3`）自动补货，避免 Scripts 领取时缺货

---

## 8. Google 表格（最简约定）

- **Sheet1（清单）**：Scripts 写入；API 读取
  - `campaignName`：广告系列名称
  - `campaignId`：广告系列 ID
  - `country`：投放国家（例如 US、UK），用于代理选择时匹配出口国家
  - `finalUrl`：最终到达网址
  - `todayClicks`：今日累计点击数（使用 `segments.date DURING TODAY` 和 `metrics.clicks` 获取，无今日数据时默认为 0）
  - `cid`：子账号 CID（必需）
  - `mccId`：MCC ID（必需）
  - `updatedAt`：写入时间


> **重要**：
> - 一致性状态（`lastAppliedClicks`、租约）由 **API 保存**，脚本/表格不承担一致性锁。
> - 表格只作为"清单/可视化/导入来源（Sheet1）"与"可选运行日志（Sheet2）"。
> - **业务是否生效以数据库为准**，表格写入成功不代表已同步成功。

---

## 9. 待办事项清单（2026-01-20 更新）

### P0 - 必须修复（上线阻塞）

- [ ] **修复 Prisma findUnique 查询语法错误**
  - 文件: `src/app/api/v1/suffix/lease/route.ts`
  - 文件: `src/app/api/v1/suffix/lease/batch/route.ts`
  - 改用 `findFirst` 或分两步查询

### P1 - 重要优化

- [ ] **整合代理验证逻辑到 Suffix 生成**
  - 复用 `redirect/tracker.ts` 的能力到 `suffix-generator.ts`
  - 实现真正的代理访问 → 追踪 → 生成 suffix 流程

- [ ] **告警持久化**
  - 将告警历史从内存存储改为数据库存储
  - 支持告警查询和统计

### P2 - 功能完善

- [ ] **Google Ads Scripts 完善**
  - 确认 `campaign_sync_to_sheet.js` 与 API 的对接
  - 测试完整的 lease → write → ack 流程

- [ ] **补充单元测试**
  - 核心 API 接口测试
  - 库存补货逻辑测试

### 已完成 ✅

- [x] 核心 API 接口 (lease, ack, sync, batch)
- [x] 库存补货后台任务
- [x] Cron 定时任务调度器
- [x] 监控告警系统
- [x] 租约超时回收
- [x] 前端管理界面
- [x] 链接管理模块
- [x] 联盟网络同步（7 个平台）
- [x] 代理验证系统
- [x] 用户管理
- [x] 代理供应商管理
